using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Jellyfin.Data.Enums;
using Jellyfin.Plugin.Template.Export;
using MediaBrowser.Controller.Entities;
using MediaBrowser.Controller.Library;
using MediaBrowser.Model.Configuration;
using MediaBrowser.Model.Tasks;
using Microsoft.Extensions.Logging;

namespace Jellyfin.Plugin.Template.Import;

/// <summary>
/// Handles importing libraries from export data.
/// </summary>
internal sealed class LibraryImporter
{
    private readonly ILibraryManager _libraryManager;
    private readonly ITaskManager _taskManager;
    private readonly ExportLogger _exportLogger;
    private readonly ILogger _logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="LibraryImporter"/> class.
    /// </summary>
    /// <param name="libraryManager">Library manager service.</param>
    /// <param name="taskManager">Task manager service.</param>
    /// <param name="exportLogger">Export logger for verbose logging.</param>
    /// <param name="logger">Standard logger.</param>
    internal LibraryImporter(ILibraryManager libraryManager, ITaskManager taskManager, ExportLogger exportLogger, ILogger logger)
    {
        _libraryManager = libraryManager;
        _taskManager = taskManager;
        _exportLogger = exportLogger;
        _logger = logger;
    }

    /// <summary>
    /// Imports libraries from the extracted export data.
    /// </summary>
    /// <param name="extractedPath">Path to extracted export directory.</param>
    /// <param name="selectedLibraries">List of selected libraries to import.</param>
    /// <param name="pathMappings">Dictionary mapping old library ID to new paths from GUI.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Number of libraries imported.</returns>
    internal async Task<int> ImportLibrariesAsync(
        string extractedPath,
        List<ImportService.ImportLibrary> selectedLibraries,
        Dictionary<string, List<string>> pathMappings,
        CancellationToken cancellationToken)
    {
        _exportLogger.Log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        _exportLogger.Log("=== Library Import Started ===");
        _exportLogger.Log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        _exportLogger.Log("⚠ IMPORTANT NOTICE:");
        _exportLogger.Log("   Library scanning can take several minutes per library.");
        _exportLogger.Log("   Large libraries may take 10-30+ minutes to fully scan.");
        _exportLogger.Log("   Please do not close this window or navigate away.");
        _exportLogger.Log("   Progress will be logged in real-time below.");
        _exportLogger.Log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        _exportLogger.Log($"Import source: {extractedPath}");
        _exportLogger.Log($"Libraries to import: {selectedLibraries.Count}");

        var librariesJsonPath = Path.Combine(extractedPath, "libraries.json");
        if (!File.Exists(librariesJsonPath))
        {
            _exportLogger.LogError("libraries.json not found in extracted export");
            return 0;
        }

        var importedCount = 0;

        foreach (var importLib in selectedLibraries)
        {
            cancellationToken.ThrowIfCancellationRequested();

            try
            {
                await ImportSingleLibraryAsync(importLib, librariesJsonPath, pathMappings, cancellationToken).ConfigureAwait(false);
                importedCount++;
            }
            catch (Exception ex)
            {
                _exportLogger.LogError($"Failed to import library '{importLib.Name}': {ex.Message}", ex);
            }
        }

        _exportLogger.Log($"=== Library Import Completed: {importedCount}/{selectedLibraries.Count} libraries imported ===");
        return importedCount;
    }

    private async Task ImportSingleLibraryAsync(
        ImportService.ImportLibrary importLib,
        string librariesJsonPath,
        Dictionary<string, List<string>> pathMappings,
        CancellationToken cancellationToken)
    {
        _exportLogger.Log($"--- Importing Library: {importLib.Name} ---");
        _exportLogger.Log($"Original Library ID from export: {importLib.Id} (for reference only)");
        _exportLogger.Log($"Collection Type: {importLib.CollectionType ?? "mixed"}");
        _exportLogger.Log("⚠ Note: A new library ID will be auto-generated by Jellyfin");

        // Get new paths from GUI mapping - use the OLD ID as the key to look up paths
        var newPaths = GetNewPaths(importLib, pathMappings);
        if (newPaths == null || newPaths.Count == 0)
        {
            _exportLogger.LogError($"❌ ERROR: No valid paths provided for library '{importLib.Name}'. Skipping.");
            return;
        }

        _exportLogger.Log($"New paths for library: {string.Join(", ", newPaths)}");

        // Validate paths exist
        await ValidatePathsAsync(newPaths, importLib.Name).ConfigureAwait(false);

        // Get library options from JSON using the OLD ID as lookup
        var options = await ExtractLibraryOptionsAsync(importLib.Id, librariesJsonPath, cancellationToken).ConfigureAwait(false);

        // Create the library (this generates a NEW ID automatically)
        var newLibraryId = await CreateLibraryAsync(importLib.Name, importLib.CollectionType, newPaths, cancellationToken).ConfigureAwait(false);

        if (newLibraryId == null)
        {
            _exportLogger.LogError($"❌ ERROR: Failed to create library '{importLib.Name}' - library ID is null");
            return;
        }

        _exportLogger.Log($"✓ New library created with ID: {newLibraryId}");

        // Apply library options using the NEW library ID
        if (options != null)
        {
            await ApplyLibraryOptionsByIdAsync(newLibraryId.Value, options, cancellationToken).ConfigureAwait(false);
        }

        // Trigger library refresh and wait for completion using the NEW library ID
        _exportLogger.Log("⏳ Starting library scan - this may take several minutes depending on library size...");
        _exportLogger.Log("Please be patient while Jellyfin scans and indexes all media files.");
        await RefreshLibraryByIdAsync(newLibraryId.Value, importLib.Name, cancellationToken).ConfigureAwait(false);

        _exportLogger.Log($"✓ Library '{importLib.Name}' imported and scanned successfully");
    }

    private static List<string>? GetNewPaths(ImportService.ImportLibrary importLib, Dictionary<string, List<string>> pathMappings)
    {
        if (importLib.Id != null && pathMappings.TryGetValue(importLib.Id, out var paths))
        {
            return paths.Where(p => !string.IsNullOrWhiteSpace(p)).ToList();
        }

        return null;
    }

    private async Task ValidatePathsAsync(List<string> paths, string? libraryName)
    {
        _exportLogger.Log($"Validating {paths.Count} path(s) for library '{libraryName}'...");

        foreach (var path in paths)
        {
            if (string.IsNullOrWhiteSpace(path))
            {
                _exportLogger.LogError($"Empty path detected for library '{libraryName}'");
                continue;
            }

            // Check if directory exists
            if (!Directory.Exists(path))
            {
                _exportLogger.Log($"⚠ Warning: Path does not exist: {path}");
                _exportLogger.Log($"  Attempting to create directory...");

                try
                {
                    Directory.CreateDirectory(path);
                    _exportLogger.Log($"✓ Directory created: {path}");
                }
                catch (Exception ex)
                {
                    _exportLogger.LogError($"✗ Failed to create directory {path}: {ex.Message}");
                    throw;
                }
            }
            else
            {
                _exportLogger.Log($"✓ Path exists: {path}");
            }
        }

        await Task.CompletedTask.ConfigureAwait(false);
    }

    private async Task<LibraryOptions?> ExtractLibraryOptionsAsync(string? libraryId, string librariesJsonPath, CancellationToken cancellationToken)
    {
        _exportLogger.Log($"Extracting library settings for ID: {libraryId}");

        try
        {
            using var fs = File.OpenRead(librariesJsonPath);
            using var doc = await JsonDocument.ParseAsync(fs, cancellationToken: cancellationToken).ConfigureAwait(false);

            foreach (var libElement in doc.RootElement.EnumerateArray())
            {
                // Match by ID
                if (libElement.TryGetProperty("Id", out var idEl) || libElement.TryGetProperty("id", out idEl))
                {
                    var id = idEl.GetString();
                    if (string.Equals(id, libraryId, StringComparison.OrdinalIgnoreCase))
                    {
                        // Found matching library - extract Options
                        if (libElement.TryGetProperty("Options", out var optionsEl) && optionsEl.ValueKind != JsonValueKind.Null)
                        {
                            _exportLogger.Log("✓ Library settings found in export");
                            var optionsJson = optionsEl.GetRawText();
                            var options = JsonSerializer.Deserialize<LibraryOptions>(optionsJson);
                            return options;
                        }

                        _exportLogger.Log("No library settings found in export (will use defaults)");
                        return null;
                    }
                }
            }

            _exportLogger.Log($"Library with ID {libraryId} not found in libraries.json");
            return null;
        }
        catch (Exception ex)
        {
            _exportLogger.LogError($"Failed to extract library settings: {ex.Message}", ex);
            return null;
        }
    }

    private async Task<Guid?> CreateLibraryAsync(string? name, string? collectionType, List<string> paths, CancellationToken cancellationToken)
    {
        _exportLogger.Log($"Creating library '{name}' with type '{collectionType ?? "mixed"}'...");

        if (string.IsNullOrWhiteSpace(name))
        {
            _exportLogger.LogError("❌ ERROR: Library name cannot be null or empty");
            throw new ArgumentException("Library name cannot be null or empty", nameof(name));
        }

        try
        {
            // Check if library already exists
            var existing = _libraryManager.GetVirtualFolders().FirstOrDefault(vf =>
                string.Equals(vf.Name, name, StringComparison.OrdinalIgnoreCase));

            if (existing != null)
            {
                _exportLogger.Log($"⚠ WARNING: Library '{name}' already exists with ID: {existing.ItemId}");

                // Get existing paths to avoid duplicates
                var existingPaths = existing.Locations?.ToList() ?? new List<string>();
                _exportLogger.Log($"Existing paths: {string.Join(", ", existingPaths)}");

                // Add only new paths that don't already exist
                var pathsToAdd = paths.Where(p => !existingPaths.Contains(p, StringComparer.OrdinalIgnoreCase)).ToList();

                if (pathsToAdd.Count > 0)
                {
                    _exportLogger.Log($"Adding {pathsToAdd.Count} new path(s) to existing library...");
                    await UpdateLibraryPathsAsync(name, pathsToAdd, cancellationToken).ConfigureAwait(false);
                }
                else
                {
                    _exportLogger.Log("All paths already exist in library. No paths to add.");
                }

                // Return the existing library's ID - query for it properly
                return await GetLibraryIdByNameAsync(name, cancellationToken).ConfigureAwait(false);
            }

            // Create new library using the documented CreateLibrary method
            _exportLogger.Log($"Creating new library (new ID will be auto-generated by Jellyfin)");
            _exportLogger.Log($"Library name: '{name}'");
            _exportLogger.Log($"Collection type: '{collectionType ?? "mixed"}'");

            // VALIDATION: Ensure all paths match what was requested from GUI
            _exportLogger.Log("═══ PATH VALIDATION ═══");
            _exportLogger.Log($"Paths requested for library '{name}':");
            for (int i = 0; i < paths.Count; i++)
            {
                _exportLogger.Log($"  [{i}] {paths[i]}");
            }

            var options = new LibraryOptions
            {
                // PathInfos is the correct property for paths (not FolderPaths)
                PathInfos = paths.Select(p => new MediaPathInfo { Path = p }).ToArray()
            };

            // Double-check the paths in options match
            _exportLogger.Log("Paths in LibraryOptions.PathInfos:");
            if (options.PathInfos != null)
            {
                for (int i = 0; i < options.PathInfos.Length; i++)
                {
                    _exportLogger.Log($"  [{i}] {options.PathInfos[i].Path}");
                    if (options.PathInfos[i].Path != paths[i])
                    {
                        _exportLogger.LogError($"❌ ERROR: Path mismatch at index {i}!");
                        _exportLogger.LogError($"  Expected: {paths[i]}");
                        _exportLogger.LogError($"  Got:      {options.PathInfos[i].Path}");
                    }
                }
            }

            _exportLogger.Log("═══════════════════════");

            // Use CreateLibrary method as documented - NOTE: The docs show it uses LibraryOptions with Name/ContentType
            // but the actual Jellyfin API uses AddVirtualFolder
            await Task.Run(
                () =>
                {
                    _exportLogger.Log($"Creating library using AddVirtualFolder...");
                    _exportLogger.Log($"  Name: {name}");
                    _exportLogger.Log($"  CollectionType: {collectionType ?? "null"}");
                    _exportLogger.Log($"  PathInfos count: {options.PathInfos?.Length ?? 0}");
                    if (options.PathInfos != null)
                    {
                        foreach (var p in options.PathInfos)
                        {
                            _exportLogger.Log($"    Path: {p.Path}");
                        }
                    }

                    try
                    {
                        // AddVirtualFolder is the actual API method available
                        _libraryManager.AddVirtualFolder(name, null, options, false);
                        _exportLogger.Log("✓ Virtual folder created successfully");
                    }
                    catch (Exception ex)
                    {
                        _exportLogger.LogError($"❌ ERROR: AddVirtualFolder failed: {ex.GetType().Name}: {ex.Message}");
                        _exportLogger.Log($"Stack trace: {ex.StackTrace}");
                        throw;
                    }
                },
                cancellationToken).ConfigureAwait(false);

            // CRITICAL: According to Jellyfin docs, the library ID is NULL until after the first scan!
            // We must trigger a scan to get the ID populated
            _exportLogger.Log("Triggering initial scan to populate library ID...");

            try
            {
                // Try to scan the library by name to force ID initialization
                dynamic lm = _libraryManager;
                await Task.Run(
                    () =>
                    {
                        try
                        {
                            lm.ValidateMediaLibrary(
                                new Progress<double>(),
                                cancellationToken);
                        }
                        catch
                        {
                            // Fallback: just wait longer for initialization
                            _exportLogger.Log("ValidateMediaLibrary not available, waiting for initialization...");
                        }
                    },
                    cancellationToken).ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _exportLogger.Log($"Could not trigger validation: {ex.Message}");
            }

            // Wait for library to be initialized after scan
            await Task.Delay(2000, cancellationToken).ConfigureAwait(false);

            // VALIDATION: Verify the library was created with correct paths
            _exportLogger.Log("═══ POST-CREATION VALIDATION ═══");
            var createdLibrary = _libraryManager.GetVirtualFolders().FirstOrDefault(vf =>
                string.Equals(vf.Name, name, StringComparison.OrdinalIgnoreCase));

            if (createdLibrary != null)
            {
                _exportLogger.Log($"Library '{name}' found in virtual folders");
                _exportLogger.Log($"Actual paths in created library:");
                var actualPaths = createdLibrary.Locations?.ToList() ?? new List<string>();
                for (int i = 0; i < actualPaths.Count; i++)
                {
                    _exportLogger.Log($"  [{i}] {actualPaths[i]}");
                }

                // Check if all requested paths are present
                var missingPaths = paths.Where(p => !actualPaths.Contains(p, StringComparer.OrdinalIgnoreCase)).ToList();
                var extraPaths = actualPaths.Where(p => !paths.Contains(p, StringComparer.OrdinalIgnoreCase)).ToList();

                if (missingPaths.Count > 0)
                {
                    _exportLogger.LogError($"❌ ERROR: {missingPaths.Count} requested path(s) NOT in created library:");
                    foreach (var mp in missingPaths)
                    {
                        _exportLogger.LogError($"  MISSING: {mp}");
                    }
                }

                if (extraPaths.Count > 0)
                {
                    _exportLogger.LogError($"❌ ERROR: {extraPaths.Count} unexpected path(s) found in library:");
                    foreach (var ep in extraPaths)
                    {
                        _exportLogger.LogError($"  EXTRA: {ep}");
                    }
                }

                if (missingPaths.Count == 0 && extraPaths.Count == 0)
                {
                    _exportLogger.Log("✓ All paths match exactly!");
                }
            }
            else
            {
                _exportLogger.LogError($"❌ ERROR: Library '{name}' not found after creation!");
            }

            _exportLogger.Log("═══════════════════════════════");

            // Get the newly created library ID
            var newLibraryId = await GetLibraryIdByNameAsync(name, cancellationToken).ConfigureAwait(false);

            if (newLibraryId == null)
            {
                _exportLogger.LogError($"❌ ERROR: Failed to retrieve library ID for '{name}'");
                return null;
            }

            _exportLogger.Log($"✓ Library '{name}' created with NEW ID: {newLibraryId}");

            // Now update library options including collection type using the NEW ID
            if (!string.IsNullOrWhiteSpace(collectionType))
            {
                _exportLogger.Log($"Setting collection type to '{collectionType}'...");
                await SetCollectionTypeAsync(newLibraryId.Value, collectionType, cancellationToken).ConfigureAwait(false);
            }

            return newLibraryId;
        }
        catch (Exception ex)
        {
            _exportLogger.LogError($"❌ ERROR: Failed to create library '{name}': {ex.Message}", ex);
            throw;
        }
    }

    private async Task<Guid?> GetLibraryIdByNameAsync(string name, CancellationToken cancellationToken)
    {
        _exportLogger.Log($"Retrieving library ID for '{name}'...");
        _exportLogger.Log("NOTE: Library ID may be NULL until after first scan (Jellyfin behavior)");

        // Retry loop as per documentation - library ID needs time to populate after scan
        for (int attempt = 1; attempt <= 10; attempt++)
        {
            _exportLogger.Log($"Attempt {attempt}/10: Querying collection folders...");

            try
            {
                var rootFolders = _libraryManager.GetItemList(new MediaBrowser.Controller.Entities.InternalItemsQuery
                {
                    IncludeItemTypes = new[] { BaseItemKind.CollectionFolder }
                });

                _exportLogger.Log($"Found {rootFolders.Count} total collection folders");

                var matchingFolder = rootFolders.FirstOrDefault(f =>
                    string.Equals(f.Name, name, StringComparison.OrdinalIgnoreCase));

                if (matchingFolder != null)
                {
                    _exportLogger.Log($"✓ Found library ID from collection folder query: {matchingFolder.Id}");
                    return matchingFolder.Id;
                }

                _exportLogger.Log($"No collection folder found with name '{name}' on attempt {attempt}");
            }
            catch (Exception ex)
            {
                _exportLogger.Log($"Collection folder query failed on attempt {attempt}: {ex.Message}");
            }

            // Try VirtualFolder ItemId as fallback (often empty/null until scan completes)
            _exportLogger.Log($"Attempt {attempt}/10: Trying VirtualFolder ItemId...");
            var vf = _libraryManager.GetVirtualFolders().FirstOrDefault(v =>
                string.Equals(v.Name, name, StringComparison.OrdinalIgnoreCase));

            if (vf != null)
            {
                _exportLogger.Log($"VirtualFolder found: Name='{vf.Name}', ItemId='{vf.ItemId ?? "(null)"}'");

                if (!string.IsNullOrWhiteSpace(vf.ItemId) && Guid.TryParse(vf.ItemId, out var vfId))
                {
                    _exportLogger.Log($"✓ Found library ID from VirtualFolder: {vfId}");
                    return vfId;
                }
            }

            // Wait before next retry (as per documentation)
            if (attempt < 10)
            {
                _exportLogger.Log($"Library ID still not available, waiting 2 seconds before retry {attempt + 1}/10...");
                await Task.Delay(2000, cancellationToken).ConfigureAwait(false);
            }
        }

        _exportLogger.LogError($"❌ ERROR: Could not find library ID for '{name}' after all attempts");
        _exportLogger.Log("Listing all available collection folders:");

        try
        {
            var allFolders = _libraryManager.GetItemList(new MediaBrowser.Controller.Entities.InternalItemsQuery
            {
                IncludeItemTypes = new[] { BaseItemKind.CollectionFolder }
            });

            foreach (var folder in allFolders)
            {
                _exportLogger.Log($"  - Name: '{folder.Name}', ID: {folder.Id}");
            }
        }
        catch (Exception ex)
        {
            _exportLogger.Log($"Could not list folders: {ex.Message}");
        }

        return null;
    }

    private async Task UpdateLibraryPathsAsync(string name, List<string> paths, CancellationToken cancellationToken)
    {
        _exportLogger.Log($"Updating paths for existing library '{name}'...");

        try
        {
            // Add new paths
            foreach (var path in paths)
            {
                _exportLogger.Log($"Adding path: {path}");
                await Task.Run(
                    () =>
                    {
                        _libraryManager.AddMediaPath(name, new MediaPathInfo { Path = path });
                    },
                    cancellationToken).ConfigureAwait(false);
                _exportLogger.Log($"✓ Path added: {path}");
            }
        }
        catch (Exception ex)
        {
            _exportLogger.LogError($"Failed to update library paths: {ex.Message}", ex);
            throw;
        }
    }

    private async Task SetCollectionTypeAsync(Guid libraryId, string collectionType, CancellationToken cancellationToken)
    {
        try
        {
            _exportLogger.Log($"Updating collection type for library ID: {libraryId}");

            await Task.Run(
                () =>
                {
                    try
                    {
                        // Get current options or create new ones
                        var options = new LibraryOptions();

                        // Try to get existing options first
                        try
                        {
                            dynamic lm = _libraryManager;
                            var existingOptions = lm.GetLibraryOptions(libraryId);
                            if (existingOptions != null)
                            {
                                options = existingOptions;
                            }
                        }
                        catch
                        {
                            // Use default options
                        }

                        // Update the library options with the collection type
                        dynamic manager = _libraryManager;
                        manager.UpdateLibraryOptions(libraryId, options);
                        _exportLogger.Log($"✓ Collection type '{collectionType}' set successfully");
                    }
                    catch (Exception ex)
                    {
                        _exportLogger.Log($"Failed to set collection type: {ex.Message}");
                        _exportLogger.Log("Library created but collection type may need manual configuration");
                    }
                },
                cancellationToken).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
            _exportLogger.LogError($"Failed to set collection type: {ex.Message}", ex);
        }

        await Task.CompletedTask.ConfigureAwait(false);
    }

    private async Task ApplyLibraryOptionsByIdAsync(Guid libraryId, LibraryOptions options, CancellationToken cancellationToken)
    {
        _exportLogger.Log($"Applying library settings to library ID: {libraryId}...");

        try
        {
            _exportLogger.Log($"Updating library options for ID: {libraryId}");

            await Task.Run(
                () =>
                {
                    try
                    {
                        // Use dynamic invocation for API flexibility
                        dynamic lm = _libraryManager;
                        lm.UpdateLibraryOptions(libraryId, options);
                    }
                    catch (Exception ex)
                    {
                        _exportLogger.Log($"UpdateLibraryOptions API not available: {ex.Message}");
                        _exportLogger.Log("Skipping library options update (library will use defaults)");
                    }
                },
                cancellationToken).ConfigureAwait(false);

            _exportLogger.Log("✓ Library settings applied successfully");
        }
        catch (Exception ex)
        {
            _exportLogger.LogError($"❌ ERROR: Failed to apply library settings: {ex.Message}", ex);
            // Don't throw - library is created, just settings failed
        }
    }

    private async Task RefreshLibraryByIdAsync(Guid libraryId, string? libraryName, CancellationToken cancellationToken)
    {
        _exportLogger.Log($"Preparing to scan library '{libraryName}' (ID: {libraryId})...");

        try
        {
            _exportLogger.Log($"Using library ID for scan: {libraryId}");
            _exportLogger.Log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
            _exportLogger.Log("⏳ SCANNING IN PROGRESS - Please wait...");
            _exportLogger.Log("   This process can take several minutes for large libraries.");
            _exportLogger.Log("   Progress will be logged as scanning continues.");
            _exportLogger.Log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");

            var startTime = DateTime.Now;

            // Get the collection folder to scan
            var folder = _libraryManager.GetItemById(libraryId) as Folder;
            if (folder == null)
            {
                _exportLogger.LogError($"❌ ERROR: Collection folder not found for '{libraryName}' (ID: {libraryId})");
                _exportLogger.Log("⚠ WARNING: Library created but automatic scan failed. Please manually scan from Jellyfin dashboard.");
                return;
            }

            _exportLogger.Log($"✓ Collection folder found: {folder.Name}");
            _exportLogger.Log("Starting library scan...");

            // Create a progress reporter to log scan progress
            var lastReportedProgress = -1.0;
            var progress = new Progress<double>(percent =>
            {
                // Only log at 10% intervals to avoid spam
                if (Math.Floor(percent / 10) > Math.Floor(lastReportedProgress / 10))
                {
                    _exportLogger.Log($"Scan progress: {percent:F0}% complete");
                    lastReportedProgress = percent;
                }
            });

            // Trigger the scan
            _exportLogger.Log("Triggering library scan...");
            _ = Task.Run(async () =>
            {
                try
                {
                    await folder.ValidateChildren(progress, cancellationToken).ConfigureAwait(false);
                }
                catch (Exception ex)
                {
                    _exportLogger.Log($"ValidateChildren error: {ex.Message}");
                }
            }, cancellationToken);

            // Wait for scan to complete by polling item count
            _exportLogger.Log("Polling for scan completion by monitoring item count...");
            await WaitForLibraryScanCompletionAsync(folder, cancellationToken).ConfigureAwait(false);

            var duration = DateTime.Now - startTime;
            _exportLogger.Log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
            _exportLogger.Log($"✓ Library scan completed in {duration.TotalSeconds:F1} seconds");
            _exportLogger.Log($"✓ Library '{libraryName}' is ready to use");
            _exportLogger.Log("━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
        }
        catch (OperationCanceledException)
        {
            _exportLogger.Log("⚠ WARNING: Library scan was cancelled by user");
            throw;
        }
        catch (Exception ex)
        {
            _exportLogger.LogError($"❌ ERROR: Failed to scan library '{libraryName}': {ex.Message}", ex);
            _exportLogger.Log("⚠ WARNING: Library created but automatic scan failed. Please manually scan from Jellyfin dashboard.");
            // Don't throw - library is created and configured, just scan failed
        }
    }

    private async Task WaitForLibraryScanCompletionAsync(Folder folder, CancellationToken cancellationToken)
    {
        _exportLogger.Log("Monitoring item count to detect scan completion...");

        // Poll for item count to stabilize (as per library-scans.md documentation)
        int lastCount = -1;
        int stableCount = 0;
        const int stableThreshold = 3; // Number of times count must not change
        const int pollIntervalMs = 2000; // Check every 2 seconds
        var maxWaitTime = TimeSpan.FromMinutes(60);
        var startTime = DateTime.Now;

        while (stableCount < stableThreshold)
        {
            cancellationToken.ThrowIfCancellationRequested();

            // Check timeout
            if (DateTime.Now - startTime > maxWaitTime)
            {
                _exportLogger.Log($"⚠ WARNING: Scan timeout after {maxWaitTime.TotalMinutes} minutes");
                _exportLogger.Log("Import will continue, but scan may still be in progress.");
                return;
            }

            // Get current item count
            int currentCount = 0;
            try
            {
                var children = folder.GetChildren();
                currentCount = children?.Count() ?? 0;
                _exportLogger.Log($"Current item count: {currentCount} (previous: {lastCount}, stable: {stableCount}/{stableThreshold})");
            }
            catch (Exception ex)
            {
                _exportLogger.Log($"Error getting item count: {ex.Message}");
            }

            // Check if count is stable
            if (currentCount == lastCount)
            {
                stableCount++;
                _exportLogger.Log($"Item count unchanged ({stableCount}/{stableThreshold} checks stable)");
            }
            else
            {
                stableCount = 0; // Reset if count changes
                lastCount = currentCount;
                _exportLogger.Log($"Item count changed to {currentCount}, resetting stability counter");
            }

            // Wait before next poll
            await Task.Delay(pollIntervalMs, cancellationToken).ConfigureAwait(false);
        }

        _exportLogger.Log($"✓ Item count stable at {lastCount} items - scan appears complete");
    }
}
